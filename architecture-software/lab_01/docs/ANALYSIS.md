# Пояснення до коду — Лабораторна робота 1.2
## Симуляція поведінки тварин: кіт, папуга, змія

---

## Структура проєкту

```
src/
├── interfaces/index.ts     — інтерфейси здібностей тварин
├── models/
│   ├── Animal.ts           — абстрактний базовий клас
│   ├── Cat.ts
│   ├── Parrot.ts
│   └── Snake.ts
├── care/
│   ├── Owner.ts            — хазяїн тварини
│   └── WildLife.ts         — тварина на волі
├── simulation/
│   └── TimeSimulator.ts    — симулятор часу
└── main.ts                 — демонстрація
```

---

## Методичні вимоги та їх виконання

---

### 1. Різні характеристики/сутності та специфічні операції не повинні бути в одному класі

У проєкті кожен клас має одну чітку відповідальність (SRP):

- `Animal` — зберігає стан тварини (живий/мертвий, голодний, щасливий) та перевіряє умови виживання
- `Cat`, `Parrot`, `Snake` — реалізують специфічні для кожного виду дії (бігти, літати, повзати)
- `Owner` — логіка догляду (годування, прибирання) та виведення повідомлень на консоль
- `WildLife` — поведінка тварини без хазяїна
- `TimeSimulator` — просування часу в симуляції

Консольний вивід навмисно винесений за межі класу `Animal` у `Owner` та `WildLife`,
оскільки за умовою завдання виведення повідомлень має бути відокремлене від методів предметної області.

---

### 2. Функціонал повинен бути легко розширюваним без змін в існуючому коді

Якщо потрібно додати нову тварину — наприклад, собаку — достатньо створити новий клас:

```typescript
export class Dog extends Animal implements ICanWalk, ICanRun, ICanTalk {
  readonly species = "Собака";
  walk(): void { ... }
  run(): void { ... }
  talk(): void { ... }
}
```

Класи `Animal`, `Owner`, `TimeSimulator` при цьому не змінюються.
Це відповідає принципу відкритості/закритості (OCP).

Аналогічно, якщо потрібно додати новий спосіб догляду — наприклад, ветеринарний огляд —
можна створити клас `Vet` за зразком `Owner`, підписавшись на події тварини.

---

### 3. При однотипних операціях використовується абстракція

Всі три тварини мають спільну логіку: стан живий/мертвий, голод, щастя, годування, прибирання.
Ця логіка винесена в абстрактний клас `Animal`, щоб не дублювати її в кожному підкласі.

Методи `canAct()` та `canRunOrFly()` визначені один раз в `Animal` і використовуються
у всіх підкласах — замість того, щоб в кожному класі писати однакову перевірку окремо.

Вибір між інтерфейсом і абстрактним класом:
- Для здібностей (`ICanWalk`, `ICanRun` тощо) використані **інтерфейси**, тому що це контракт
  без реалізації — кожна тварина реалізує рух по-своєму.
- Для `Animal` використаний **абстрактний клас**, тому що тут є спільна реалізація (стан, події,
  лічильники), яку немає сенсу дублювати. Інтерфейс тут не підійшов би, бо він не містить реалізацію.

---

### 4. Код не повторюється і є читабельним

Перевірки `canAct()` і `canRunOrFly()` записані один раз в `Animal`.
Підписка на події і їх скасування — через масив функцій `_unsubscribers`, що дозволяє
одним викликом `dispose()` відписатись від усього.

---

### 5. Реалізовано тільки те, що вказане в завданні

Реалізовані тільки вимоги із завдання:
- три тварини: кіт, папуга, змія
- здібності відповідно до виду
- правила годування: мін 1, макс 5 на день, рівні проміжки
- смерть від голоду (24 год) та переїдання (понад 5 прийомів)
- обмеження на біг/політ при голоді (>8 год без їжі)
- хазяїн з однією твариною, догляд: годування + прибирання
- щастя від прибирання (>= 1 раз на день)
- тварина на волі (WildLife)

Зайвий функціонал (наприклад, ім'я хазяїна у тварини, список тварин у хазяїна,
статистика за тиждень) не реалізований.

---

### 6. Зміну стану реалізовано через механізм подій

У класі `Animal` є п'ять типів подій:
- `onHungry` — спрацьовує коли тварина голодна
- `onFed` — після успішного годування
- `onCleaned` — після прибирання
- `onHappinessChanged` — при зміні стану щастя
- `onDied` — при загибелі тварини

Підписка реалізована через масив функцій-обробників. Метод `onHungry(handler)` додає
обробник і повертає функцію відписки. Це дозволяє `Owner` підписатись і пізніше
відписатись через `dispose()`.

```typescript
// підписка
const unsub = animal.onHungry(a => console.log(`${a.name} голодний`));

// відписка
unsub();
```

---

## Відповіді на питання по коду

---

### `interfaces/index.ts`

**Для чого цей код:**
Шість окремих інтерфейсів — `ICanEat`, `ICanWalk`, `ICanRun`, `ICanFly`, `ICanCrawl`, `ICanTalk`.
Кожен відповідає за одну здібність.

**Чому саме так:**
Якби всі здібності були в одному інтерфейсі `IAnimal`, змія мала б реалізовувати `run()` і `fly()`,
а кіт — `crawl()`. Це суперечить принципу розділення інтерфейсів (ISP).
Окремі інтерфейси дозволяють TypeScript перевіряти: якщо змінна має тип `ICanFly`,
значить у неї точно є метод `fly()`.

**Як можна зробити по-іншому:**
Можна використати один інтерфейс з опціональними методами (`fly?(): void`).
Але тоді при виклику `animal.fly()` TypeScript вимагав би перевірки на `undefined`,
що робить код менш зручним.

**Що зміниться якщо видалити:**
Компілятор не зможе перевіряти наявність методів. Наприклад, `(kesha as ICanFly).fly()`
просто не скомпілюється без інтерфейсу `ICanFly`.

---

### `models/Animal.ts` — константи

```typescript
private static readonly MAX_MEALS_PER_DAY = 5;
private static readonly MIN_MEAL_INTERVAL_H = 24 / Animal.MAX_MEALS_PER_DAY;
private static readonly HUNGER_THRESHOLD_H = 8;
private static readonly DEATH_THRESHOLD_H = 24;
```

**Для чого:**
Константи зберігають правила виживання тварини. `static` — одна копія на клас, а не на кожен об'єкт.
`readonly` — значення не можна змінити після ініціалізації. `private` — ніхто ззовні не може
порушити правила.

**Чому саме так:**
`MIN_MEAL_INTERVAL_H = 24 / MAX_MEALS_PER_DAY` — якщо змінити максимум прийомів, інтервал
перерахується автоматично. Немає магічних чисел розкиданих по коду.

**Як по-іншому:**
Можна винести константи у конфігураційний файл або передавати через конструктор.
Але за умовою завдання розширення не передбачене, тому це зайве.

**Що зміниться якщо видалити `MIN_MEAL_INTERVAL_H`:**
Тварина зможе з'їсти 5 порцій підряд за хвилину, що суперечить вимозі "приблизно рівні проміжки".

---

### `models/Animal.ts` — масиви обробників подій

```typescript
private _onHungryHandlers: AnimalEventHandler[] = [];
```

**Для чого:**
Масив зберігає всі функції, які підписались на подію голоду. При настанні події — усі вони викликаються.

**Чому саме так:**
Це проста реалізація патерну Observer без зовнішніх бібліотек. Масив дозволяє мати кількох
підписників (наприклад, і Owner, і якийсь логер).

**Як по-іншому:**
Можна використати `EventEmitter` з Node.js — але це додаткова залежність і відсутність типізації.
Або зберігати один обробник (не масив) — але тоді підписатись може лише один об'єкт.

**Що зміниться якщо видалити:**
Events не будуть працювати взагалі. `Owner` не отримуватиме сповіщень про стан тварини.

---

### `models/Animal.ts` — метод `eat()`

```typescript
eat(): boolean {
  if (!this._isAlive) return false;
  const hoursSinceLast = this._currentHours - this._lastMealTime;
  if (hoursSinceLast < Animal.MIN_MEAL_INTERVAL_H) return false;
  if (this._mealsToday >= Animal.MAX_MEALS_PER_DAY) {
    this._die("переїдання");
    return false;
  }
  this._lastMealTime = this._currentHours;
  this._mealsToday++;
  this._onFedHandlers.forEach(h => h(this));
  return true;
}
```

**Для чого:**
Метод змінює стан тварини (оновлює `_lastMealTime`, `_mealsToday`) і повідомляє про це через подію.
Повертає `boolean` щоб `Owner.feed()` знав, чи вдалось нагодувати.

**Чому повертає `boolean` а не кидає `Error`:**
Ситуація "ще не час їсти" є нормальною (не помилковою). `Error` використовується тільки для
справді виняткових ситуацій. Якщо `Owner` викликав `feed()` і отримав `false` — це просто
означає, що тварина ще не голодна.

**Як по-іншому:**
Можна кидати різні типи `Error` для кожного випадку. Але це ускладнює виклик — треба
обгортати в `try/catch` навіть звичайні операції.

**Що зміниться якщо видалити перевірку мінімального інтервалу:**
Тварину можна годувати 5 разів поспіль за кілька секунд — порушення умови завдання.

---

### `models/Animal.ts` — метод `advanceTime()`

```typescript
advanceTime(newHours: number): void {
  const daysPassed = Math.floor((newHours - this._dayStart) / 24);
  if (daysPassed > 0) {
    this._dayStart += daysPassed * 24;
    this._mealsToday = 0;
    this._cleansToday = 0;
    this._updateHappiness();
  }
  this._currentHours = newHours;
  this._checkVitals();
}
```

**Для чого:**
Просуває внутрішній годинник тварини, скидає денні лічильники при переході на новий день
і перевіряє стан виживання.

**Чому не `Date.now()`:**
Симульований час дозволяє в демо просунути одразу на 9 або 16 годин, не чекаючи реального часу.

**Що зміниться якщо видалити скидання `_mealsToday`:**
Лічильник їжі зростатиме нескінченно. Тварина не зможе їсти вже на другий день,
бо `_mealsToday >= MAX_MEALS_PER_DAY` спрацює відразу.

**Що зміниться якщо видалити `_updateHappiness()` після скидання:**
Тварина, яку прибирали вчора, залишиться щасливою на початку нового дня, хоча `_cleansToday` вже 0.
Щастя не буде скидатись разом з лічильником.

---

### `models/Animal.ts` — захищені методи

```typescript
protected canRunOrFly(): boolean {
  return this._isAlive && !this.isHungry;
}

protected canAct(): boolean {
  return this._isAlive;
}
```

**Для чого:**
Дозволяють підкласам (`Cat`, `Parrot`, `Snake`) перевіряти умови без прямого доступу до
приватних полів `_isAlive` та `_lastMealTime`.

**Чому `protected` а не `public`:**
Ці методи — внутрішній механізм перевірки. Зовнішній код не повинен викликати `barsyk.canRunOrFly()`.
`protected` дає доступ тільки підкласам.

**Що зміниться якщо видалити:**
У `Cat.run()` треба буде дублювати логіку перевірки голоду — але `_isAlive` є `private`,
тому код навіть не скомпілюється. Доведеться або робити поле `protected`, або дублювати перевірку
через публічний геттер `isHungry`.

---

### `models/Cat.ts`, `Parrot.ts`, `Snake.ts`

**Для чого:**
Кожен підклас реалізує тільки ті здібності, що притаманні виду.
`Cat` — `ICanWalk, ICanRun, ICanTalk`. `Snake` — `ICanCrawl, ICanTalk`.

**Чому кидають `Error` а не повертають `boolean`:**
`walk()`, `run()`, `fly()` — це команди. Або виконуються, або ні. Виклик `barsyk.run()`
коли кіт мертвий — це порушення контракту, тому `Error` тут доречний.

**Що зміниться якщо `Cat` успадкувати від `Parrot`:**
Семантично невірно. Кіт не є різновидом папуги. Кіт отримає методи `fly()`, яких у нього немає.
Тому обидва класи успадковуються від загального `Animal`.

---

### `care/Owner.ts`

```typescript
private readonly _unsubscribers: Array<() => void> = [];

dispose(): void {
  this._unsubscribers.forEach(unsub => unsub());
  this._unsubscribers.length = 0;
}
```

**Для чого:**
`on*` методи Animal повертають функцію відписки. Зберігаємо їх усі в масив,
щоб при `dispose()` відписатись від усіх подій одним викликом.

**Чому консольний вивід знаходиться тут, а не в `Animal`:**
Умова завдання: "вивід повідомлень на консоль повинен бути за межами методів предметної області".
`Animal` — це предметна область. Тому вивід — в `Owner` і `WildLife`.

**Що зміниться якщо не викликати `dispose()`:**
Підписки залишаться активними. Тварина продовжить викликати обробники `Owner`,
навіть якщо `Owner` вже не використовується. Це витік пам'яті.

---

### `care/WildLife.ts`

**Для чого:**
Представляє тварину без хазяїна. Підписується на події і виводить відповідні повідомлення.

**Чому окремий клас а не прапорець в Animal:**
Додавання `WildLife` не вимагає змін у `Animal` або `Owner`. Якщо завтра потрібно буде
клас `Shelter` (притулок для тварин) — його також додамо без змін в існуючий код.

**Що зміниться якщо видалити:**
Дикі тварини не отримуватимуть жодних сповіщень. Технічно програма не впаде,
але в демо не буде видно подій для `kesha`.

---

### `simulation/TimeSimulator.ts`

```typescript
private readonly _animals: Set<Animal> = new Set();
```

**Для чого:**
Зберігає всіх зареєстрованих тварин і при кожному `advance()` викликає `advanceTime()` для кожної.

**Чому `Set` а не `Array`:**
`Set` гарантує унікальність — одну тварину не зареєструємо двічі. В `Array` треба було б перевіряти.

**Що зміниться якщо не реєструвати тварину через `register()`:**
`advanceTime()` не буде викликатись автоматично. Час тварини не просуватиметься,
вона ніколи не зголодніє і не помре — навіть якщо `sim.advance()` викликається.
